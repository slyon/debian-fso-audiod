/* plugin.c generated by valac 0.16.0, the Vala compiler
 * generated from plugin.vala, do not modify */

/*
 * Copyright (C) 2011-2012 Simon Busch <morphis@gravedo.de>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <fsoaudio.h>
#include <freesmartphone.h>
#include <fsobasics.h>
#include <fsoframework.h>


#define FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY (fso_audio_default_session_policy_get_type ())
#define FSO_AUDIO_DEFAULT_SESSION_POLICY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY, FsoAudioDefaultSessionPolicy))
#define FSO_AUDIO_DEFAULT_SESSION_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY, FsoAudioDefaultSessionPolicyClass))
#define FSO_AUDIO_IS_DEFAULT_SESSION_POLICY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY))
#define FSO_AUDIO_IS_DEFAULT_SESSION_POLICY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY))
#define FSO_AUDIO_DEFAULT_SESSION_POLICY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY, FsoAudioDefaultSessionPolicyClass))

typedef struct _FsoAudioDefaultSessionPolicy FsoAudioDefaultSessionPolicy;
typedef struct _FsoAudioDefaultSessionPolicyClass FsoAudioDefaultSessionPolicyClass;
typedef struct _FsoAudioDefaultSessionPolicyPrivate FsoAudioDefaultSessionPolicyPrivate;

struct _FsoAudioDefaultSessionPolicy {
	FsoAudioAbstractSessionPolicy parent_instance;
	FsoAudioDefaultSessionPolicyPrivate * priv;
};

struct _FsoAudioDefaultSessionPolicyClass {
	FsoAudioAbstractSessionPolicyClass parent_class;
};

struct _FsoAudioDefaultSessionPolicyPrivate {
	guint* stream_usage;
	gint stream_usage_length1;
	gint _stream_usage_size_;
};

typedef void (*FsoAudioDefaultSessionPolicyStreamProcessFunc) (FreeSmartphoneAudioStream stream, void* user_data);

static gpointer fso_audio_default_session_policy_parent_class = NULL;
static GType fso_audio_default_session_policy_type_id = 0;

#define FSO_AUDIO_SESSIONPOLICY_DEFAULT_MODULE_NAME "fsoaudio.sessionpolicy_default"
#define FSO_AUDIO_STREAM_COUNT ((guint) 5)
GType fso_audio_default_session_policy_get_type (void) G_GNUC_CONST;
GType fso_audio_default_session_policy_register_type (GTypeModule * module);
#define FSO_AUDIO_DEFAULT_SESSION_POLICY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY, FsoAudioDefaultSessionPolicyPrivate))
enum  {
	FSO_AUDIO_DEFAULT_SESSION_POLICY_DUMMY_PROPERTY
};
static void fso_audio_default_session_policy_resetStreamUsage (FsoAudioDefaultSessionPolicy* self);
static void fso_audio_default_session_policy_processStreams (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream* streams, int streams_length1, FsoAudioDefaultSessionPolicyStreamProcessFunc process_func, void* process_func_target);
static void fso_audio_default_session_policy_handleDuckStatusForStream (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream stream, FreeSmartphoneAudioStream* streamsToProcess, int streamsToProcess_length1);
static void ___lambda2_ (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream s);
static void ____lambda2__fso_audio_default_session_policy_stream_process_func (FreeSmartphoneAudioStream stream, gpointer self);
static void ____lambda3_ (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream s);
static void _____lambda3__fso_audio_default_session_policy_stream_process_func (FreeSmartphoneAudioStream stream, gpointer self);
static void fso_audio_default_session_policy_updateStreamStatus (FsoAudioDefaultSessionPolicy* self);
static void fso_audio_default_session_policy_real_handleConnectingStream (FsoAudioAbstractSessionPolicy* base, FreeSmartphoneAudioStream stream);
static void fso_audio_default_session_policy_real_handleDisconnectingStream (FsoAudioAbstractSessionPolicy* base, FreeSmartphoneAudioStream stream);
FsoAudioDefaultSessionPolicy* fso_audio_default_session_policy_new (void);
FsoAudioDefaultSessionPolicy* fso_audio_default_session_policy_construct (GType object_type);
static GObject * fso_audio_default_session_policy_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void fso_audio_default_session_policy_finalize (GObject* obj);
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error);
void fso_register_function (GTypeModule* module);


static void fso_audio_default_session_policy_resetStreamUsage (FsoAudioDefaultSessionPolicy* self) {
	g_return_if_fail (self != NULL);
	{
		gint n;
		n = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				guint* _tmp4_;
				gint _tmp4__length1;
				gint _tmp5_;
				guint _tmp6_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = n;
					n = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = n;
				if (!(((guint) _tmp3_) < FSO_AUDIO_STREAM_COUNT)) {
					break;
				}
				_tmp4_ = self->priv->stream_usage;
				_tmp4__length1 = self->priv->stream_usage_length1;
				_tmp5_ = n;
				_tmp4_[_tmp5_] = (guint) 0;
				_tmp6_ = _tmp4_[_tmp5_];
			}
		}
	}
}


static void fso_audio_default_session_policy_processStreams (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream* streams, int streams_length1, FsoAudioDefaultSessionPolicyStreamProcessFunc process_func, void* process_func_target) {
	FreeSmartphoneAudioStream* _tmp0_;
	gint _tmp0__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = streams;
	_tmp0__length1 = streams_length1;
	{
		FreeSmartphoneAudioStream* stream_collection = NULL;
		gint stream_collection_length1 = 0;
		gint _stream_collection_size_ = 0;
		gint stream_it = 0;
		stream_collection = _tmp0_;
		stream_collection_length1 = _tmp0__length1;
		for (stream_it = 0; stream_it < _tmp0__length1; stream_it = stream_it + 1) {
			FreeSmartphoneAudioStream stream = 0;
			stream = stream_collection[stream_it];
			{
				FsoAudioDefaultSessionPolicyStreamProcessFunc _tmp1_;
				void* _tmp1__target;
				FreeSmartphoneAudioStream _tmp2_;
				_tmp1_ = process_func;
				_tmp1__target = process_func_target;
				_tmp2_ = stream;
				_tmp1_ (_tmp2_, _tmp1__target);
			}
		}
	}
}


static void ___lambda2_ (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream s) {
	FsoAudioAbstractStreamControl* _tmp0_;
	FreeSmartphoneAudioStream _tmp1_;
	_tmp0_ = ((FsoAudioAbstractSessionPolicy*) self)->stream_control;
	_tmp1_ = s;
	fso_audio_abstract_stream_control_set_mute (_tmp0_, _tmp1_, TRUE);
}


static void ____lambda2__fso_audio_default_session_policy_stream_process_func (FreeSmartphoneAudioStream stream, gpointer self) {
	___lambda2_ (self, stream);
}


static void ____lambda3_ (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream s) {
	FsoAudioAbstractStreamControl* _tmp0_;
	FreeSmartphoneAudioStream _tmp1_;
	_tmp0_ = ((FsoAudioAbstractSessionPolicy*) self)->stream_control;
	_tmp1_ = s;
	fso_audio_abstract_stream_control_set_mute (_tmp0_, _tmp1_, FALSE);
}


static void _____lambda3__fso_audio_default_session_policy_stream_process_func (FreeSmartphoneAudioStream stream, gpointer self) {
	____lambda3_ (self, stream);
}


static void fso_audio_default_session_policy_handleDuckStatusForStream (FsoAudioDefaultSessionPolicy* self, FreeSmartphoneAudioStream stream, FreeSmartphoneAudioStream* streamsToProcess, int streamsToProcess_length1) {
	guint* _tmp0_;
	gint _tmp0__length1;
	FreeSmartphoneAudioStream _tmp1_;
	guint _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->stream_usage;
	_tmp0__length1 = self->priv->stream_usage_length1;
	_tmp1_ = stream;
	_tmp2_ = _tmp0_[_tmp1_];
	if (_tmp2_ > ((guint) 0)) {
		FreeSmartphoneAudioStream* _tmp3_;
		gint _tmp3__length1;
		_tmp3_ = streamsToProcess;
		_tmp3__length1 = streamsToProcess_length1;
		fso_audio_default_session_policy_processStreams (self, _tmp3_, _tmp3__length1, ____lambda2__fso_audio_default_session_policy_stream_process_func, self);
	} else {
		guint* _tmp4_;
		gint _tmp4__length1;
		FreeSmartphoneAudioStream _tmp5_;
		guint _tmp6_;
		_tmp4_ = self->priv->stream_usage;
		_tmp4__length1 = self->priv->stream_usage_length1;
		_tmp5_ = stream;
		_tmp6_ = _tmp4_[_tmp5_];
		if (_tmp6_ == ((guint) 0)) {
			FreeSmartphoneAudioStream* _tmp7_;
			gint _tmp7__length1;
			_tmp7_ = streamsToProcess;
			_tmp7__length1 = streamsToProcess_length1;
			fso_audio_default_session_policy_processStreams (self, _tmp7_, _tmp7__length1, _____lambda3__fso_audio_default_session_policy_stream_process_func, self);
		}
	}
}


static void fso_audio_default_session_policy_updateStreamStatus (FsoAudioDefaultSessionPolicy* self) {
	FreeSmartphoneAudioStream* _tmp0_ = NULL;
	FreeSmartphoneAudioStream* _tmp1_;
	gint _tmp1__length1;
	FreeSmartphoneAudioStream* _tmp2_ = NULL;
	FreeSmartphoneAudioStream* _tmp3_;
	gint _tmp3__length1;
	FreeSmartphoneAudioStream* _tmp4_ = NULL;
	FreeSmartphoneAudioStream* _tmp5_;
	gint _tmp5__length1;
	FreeSmartphoneAudioStream* _tmp6_ = NULL;
	FreeSmartphoneAudioStream* _tmp7_;
	gint _tmp7__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_new0 (FreeSmartphoneAudioStream, 4);
	_tmp0_[0] = FREE_SMARTPHONE_AUDIO_STREAM_MEDIA;
	_tmp0_[1] = FREE_SMARTPHONE_AUDIO_STREAM_NAVIGATION;
	_tmp0_[2] = FREE_SMARTPHONE_AUDIO_STREAM_ALERT;
	_tmp0_[3] = FREE_SMARTPHONE_AUDIO_STREAM_RINGTONE;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = 4;
	fso_audio_default_session_policy_handleDuckStatusForStream (self, FREE_SMARTPHONE_AUDIO_STREAM_ALARM, _tmp1_, 4);
	_tmp1_ = (g_free (_tmp1_), NULL);
	_tmp2_ = g_new0 (FreeSmartphoneAudioStream, 3);
	_tmp2_[0] = FREE_SMARTPHONE_AUDIO_STREAM_MEDIA;
	_tmp2_[1] = FREE_SMARTPHONE_AUDIO_STREAM_NAVIGATION;
	_tmp2_[2] = FREE_SMARTPHONE_AUDIO_STREAM_ALERT;
	_tmp3_ = _tmp2_;
	_tmp3__length1 = 3;
	fso_audio_default_session_policy_handleDuckStatusForStream (self, FREE_SMARTPHONE_AUDIO_STREAM_RINGTONE, _tmp3_, 3);
	_tmp3_ = (g_free (_tmp3_), NULL);
	_tmp4_ = g_new0 (FreeSmartphoneAudioStream, 2);
	_tmp4_[0] = FREE_SMARTPHONE_AUDIO_STREAM_MEDIA;
	_tmp4_[1] = FREE_SMARTPHONE_AUDIO_STREAM_NAVIGATION;
	_tmp5_ = _tmp4_;
	_tmp5__length1 = 2;
	fso_audio_default_session_policy_handleDuckStatusForStream (self, FREE_SMARTPHONE_AUDIO_STREAM_ALERT, _tmp5_, 2);
	_tmp5_ = (g_free (_tmp5_), NULL);
	_tmp6_ = g_new0 (FreeSmartphoneAudioStream, 1);
	_tmp6_[0] = FREE_SMARTPHONE_AUDIO_STREAM_MEDIA;
	_tmp7_ = _tmp6_;
	_tmp7__length1 = 1;
	fso_audio_default_session_policy_handleDuckStatusForStream (self, FREE_SMARTPHONE_AUDIO_STREAM_NAVIGATION, _tmp7_, 1);
	_tmp7_ = (g_free (_tmp7_), NULL);
}


static void fso_audio_default_session_policy_real_handleConnectingStream (FsoAudioAbstractSessionPolicy* base, FreeSmartphoneAudioStream stream) {
	FsoAudioDefaultSessionPolicy * self;
	guint* _tmp0_;
	gint _tmp0__length1;
	FreeSmartphoneAudioStream _tmp1_;
	guint _tmp2_;
	self = (FsoAudioDefaultSessionPolicy*) base;
	_tmp0_ = self->priv->stream_usage;
	_tmp0__length1 = self->priv->stream_usage_length1;
	_tmp1_ = stream;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp0_[_tmp1_] = _tmp2_ + 1;
	fso_audio_default_session_policy_updateStreamStatus (self);
}


static void fso_audio_default_session_policy_real_handleDisconnectingStream (FsoAudioAbstractSessionPolicy* base, FreeSmartphoneAudioStream stream) {
	FsoAudioDefaultSessionPolicy * self;
	guint* _tmp0_;
	gint _tmp0__length1;
	FreeSmartphoneAudioStream _tmp1_;
	guint _tmp2_;
	guint* _tmp4_;
	gint _tmp4__length1;
	FreeSmartphoneAudioStream _tmp5_;
	guint _tmp6_;
	self = (FsoAudioDefaultSessionPolicy*) base;
	_tmp0_ = self->priv->stream_usage;
	_tmp0__length1 = self->priv->stream_usage_length1;
	_tmp1_ = stream;
	_tmp2_ = _tmp0_[_tmp1_];
	if (_tmp2_ == ((guint) 0)) {
		FsoFrameworkLogger* _tmp3_;
		_tmp3_ = ((FsoFrameworkAbstractObject*) self)->logger;
		fso_framework_logger_error (_tmp3_, "Got info about a disconnecting stream but all streams of this type alr" \
"eady have been disconnected!?");
		return;
	}
	_tmp4_ = self->priv->stream_usage;
	_tmp4__length1 = self->priv->stream_usage_length1;
	_tmp5_ = stream;
	_tmp6_ = _tmp4_[_tmp5_];
	_tmp4_[_tmp5_] = _tmp6_ - 1;
	fso_audio_default_session_policy_updateStreamStatus (self);
}


FsoAudioDefaultSessionPolicy* fso_audio_default_session_policy_construct (GType object_type) {
	FsoAudioDefaultSessionPolicy * self = NULL;
	self = (FsoAudioDefaultSessionPolicy*) fso_audio_abstract_session_policy_construct (object_type);
	return self;
}


FsoAudioDefaultSessionPolicy* fso_audio_default_session_policy_new (void) {
	return fso_audio_default_session_policy_construct (FSO_AUDIO_TYPE_DEFAULT_SESSION_POLICY);
}


static GObject * fso_audio_default_session_policy_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	FsoAudioDefaultSessionPolicy * self;
	guint* _tmp0_ = NULL;
	parent_class = G_OBJECT_CLASS (fso_audio_default_session_policy_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = FSO_AUDIO_DEFAULT_SESSION_POLICY (obj);
	_tmp0_ = g_new0 (guint, FSO_AUDIO_STREAM_COUNT);
	self->priv->stream_usage = (g_free (self->priv->stream_usage), NULL);
	self->priv->stream_usage = _tmp0_;
	self->priv->stream_usage_length1 = FSO_AUDIO_STREAM_COUNT;
	self->priv->_stream_usage_size_ = self->priv->stream_usage_length1;
	fso_audio_default_session_policy_resetStreamUsage (self);
	return obj;
}


static void fso_audio_default_session_policy_class_init (FsoAudioDefaultSessionPolicyClass * klass) {
	fso_audio_default_session_policy_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FsoAudioDefaultSessionPolicyPrivate));
	FSO_AUDIO_ABSTRACT_SESSION_POLICY_CLASS (klass)->handleConnectingStream = fso_audio_default_session_policy_real_handleConnectingStream;
	FSO_AUDIO_ABSTRACT_SESSION_POLICY_CLASS (klass)->handleDisconnectingStream = fso_audio_default_session_policy_real_handleDisconnectingStream;
	G_OBJECT_CLASS (klass)->constructor = fso_audio_default_session_policy_constructor;
	G_OBJECT_CLASS (klass)->finalize = fso_audio_default_session_policy_finalize;
}


static void fso_audio_default_session_policy_instance_init (FsoAudioDefaultSessionPolicy * self) {
	self->priv = FSO_AUDIO_DEFAULT_SESSION_POLICY_GET_PRIVATE (self);
}


static void fso_audio_default_session_policy_finalize (GObject* obj) {
	FsoAudioDefaultSessionPolicy * self;
	self = FSO_AUDIO_DEFAULT_SESSION_POLICY (obj);
	self->priv->stream_usage = (g_free (self->priv->stream_usage), NULL);
	G_OBJECT_CLASS (fso_audio_default_session_policy_parent_class)->finalize (obj);
}


GType fso_audio_default_session_policy_get_type (void) {
	return fso_audio_default_session_policy_type_id;
}


GType fso_audio_default_session_policy_register_type (GTypeModule * module) {
	static const GTypeInfo g_define_type_info = { sizeof (FsoAudioDefaultSessionPolicyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fso_audio_default_session_policy_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FsoAudioDefaultSessionPolicy), 0, (GInstanceInitFunc) fso_audio_default_session_policy_instance_init, NULL };
	fso_audio_default_session_policy_type_id = g_type_module_register_type (module, FSO_AUDIO_TYPE_ABSTRACT_SESSION_POLICY, "FsoAudioDefaultSessionPolicy", &g_define_type_info, 0);
	return fso_audio_default_session_policy_type_id;
}


/**
 * This function gets called on plugin initialization time.
 * @return the name of your plugin here
 * @note that it needs to be a name in the format <subsystem>.<plugin>
 * else your module will be unloaded immediately.
 **/
gchar* fso_factory_function (FsoFrameworkSubsystem* subsystem, GError** error) {
	gchar* result = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (subsystem != NULL, NULL);
	_tmp0_ = g_strdup (FSO_AUDIO_SESSIONPOLICY_DEFAULT_MODULE_NAME);
	result = _tmp0_;
	return result;
}


void fso_register_function (GTypeModule* module) {
	FsoFrameworkLogger* _tmp0_;
	g_return_if_fail (module != NULL);
	fso_audio_default_session_policy_register_type (module);
	_tmp0_ = fso_framework_theLogger;
	fso_framework_logger_debug (_tmp0_, "fsoaudio.sessionpolicy_default fso_register_function");
}



